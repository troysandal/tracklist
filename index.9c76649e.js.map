{"mappings":"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","sources":["src/parsers/archive.ts","src/parsers/common.ts","src/parsers/traktor.ts","src/parsers/rekordbox.ts","src/parsers/cue.ts","src/parsers/rekordboxtxt.ts","src/formatter.ts","src/index.ts","src/parsers/m3u8.ts"],"sourcesContent":["export interface ArchiveTrack {\n    key: string\n    title: string\n    artist: string\n}\nexport interface PlayedTime {\n    hours: number\n    minutes: number\n    seconds: number\n}\nexport interface PlayedDate {\n    year: number\n    month: number\n    day: number\n}\nexport interface PlaylistTrack {\n    key: string\n    collectionEntry: ArchiveTrack\n    playedPublic: boolean\n    startTime?: PlayedTime\n    startDate?: PlayedDate\n    startTimeJS?: Date\n    timeOffset?: number\n    timeOffsetString?: string\n}\nexport interface Playlist {\n    name: string\n    tracks: Array<PlaylistTrack>\n\n    filter(startIndex: number, playedLive: boolean): Playlist\n}\n\nexport type Collection = { [n: string]: ArchiveTrack }\n\nexport interface Archive {\n    collection: Collection\n    playlists: Array<Playlist>\n    format: string\n}\n\nexport interface Parser {   \n    supports(): boolean\n    parse() : Archive | null\n}\n\nexport class CPlaylist implements Playlist {\n    name:string \n    tracks: Array<PlaylistTrack>\n\n    constructor(name:string = '', tracks: Array<PlaylistTrack> = []) {\n        this.name = name\n        this.tracks = tracks\n    }\n\n    filter(startIndex: number, playedLive: boolean): Playlist {\n        let result = new CPlaylist()\n        result.name = this.name\n        result.tracks = this.tracks\n            .filter((_, index) => index >= (startIndex))\n            .filter((track) => playedLive ? track.playedPublic : true)\n\n        return result\n    }\n}\n","export function lineReader(contents:string, cb: (line:string, index:number) => void): void {\n    const lines = contents.split('\\n')\n    lines.forEach((line, index) => {\n        line = line.trim()\n        if (line.length) {\n            cb(line, index)\n        }\n    })\n}\n\n/**\n * JSDom.querySelectorAll no work with 'TAG > TAG' selectors so we got this.\n */\n export function querySelectorAllParents(xmlDoc: Element | XMLDocument | undefined, parents:string[]) {\n    while (xmlDoc && parents[0]) {\n        const tagName = parents.shift() as string\n        const isLastTag = parents.length === 0\n        const children = xmlDoc.querySelectorAll(tagName)\n\n        if (isLastTag) {\n            return children\n        }\n        xmlDoc = children[0]\n    }\n\n    return undefined\n}\n\n","import { Archive, ArchiveTrack, Collection, Playlist, CPlaylist, Parser, PlaylistTrack } from \"./archive\"\nimport { querySelectorAllParents } from \"./common\"\n\nexport class TraktorParser implements Parser {\n    static format = \"Traktor\"\n    static extensions = ['.nml']\n    xmlDoc: XMLDocument | null\n\n    constructor(contents:string) {\n        this.xmlDoc = TraktorParser.parseXML(contents)\n        if (this.xmlDoc) {\n            const root = this.xmlDoc.getElementsByTagName(\"NML\")\n            if (root.length === 0) {\n                this.xmlDoc = null\n            }\n        }\n    }\n\n    private static parseXML(contents:string) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports(): boolean {\n        return this.xmlDoc !== null\n    }\n    \n    parse(): Archive | null {\n        if (!this.xmlDoc) {\n            return null\n        }\n\n        return parseTraktor(this.xmlDoc)\n    }  \n}\n\nfunction parseTraktor(xmlDoc:XMLDocument) {\n    const archive: Archive = {\n        collection: nmlCollection(xmlDoc),\n        playlists: [],\n        format: 'Traktor NML'\n    }\n    archive.playlists = nmlPlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\n/**\n * Generates the Collection from an NML file.  Only thing to note is that we \n * are required to generate the track key from LOCATION node's attributes.\n * This is odd because PLAYLIST ENTRY node's PRIMARYKEY already has this \n * pre-computed.  Unsure why Traktor doesn't do this for COLLECTION ENTRY.\n */\nfunction nmlCollection(xmlDoc: XMLDocument): Collection {\n    // Selector we are emulating 'NML > COLLECTION > ENTRY'\n    const collectionEntries = querySelectorAllParents(xmlDoc, ['NML', 'COLLECTION', 'ENTRY']) ?? []\n\n    return Array.prototype.map.call(collectionEntries,\n        (entry: Element, index: number) => {\n            const location = entry.getElementsByTagName('LOCATION')[0] as Element\n            const key = \n                `${location.attributes.getNamedItem('VOLUME')?.value}` +\n                `${location.attributes.getNamedItem('DIR')?.value}` +\n                `${location.attributes.getNamedItem('FILE')?.value}`\n            return { \n                title: entry.attributes.getNamedItem('TITLE')?.value, \n                artist: entry.attributes.getNamedItem('ARTIST')?.value,\n                key\n            }\n        })\n        .reduce((collection: Collection, track:ArchiveTrack) => {\n            collection[track.key] = track; \n            return collection\n        }, {})\n}\n\nfunction nmlPlaylists(xmlDoc: XMLDocument, collection:Collection): Playlist[] {\n    // Selector we are emulating \"NML > PLAYLISTS NODE[TYPE='PLAYLIST']\"\n    const playlistNodes = querySelectorAllParents(xmlDoc, ['NML', 'PLAYLISTS', \"NODE[TYPE='PLAYLIST']\"]) ?? []\n\n    return Array.prototype.map.call(playlistNodes, (playlistNode: Element) => {\n        const playList = new CTraktorPlaylist(\n            playlistNode.attributes.getNamedItem('NAME')?.value,\n            []\n        )\n        const playListTrackNodes = querySelectorAllParents(playlistNode, ['PLAYLIST', 'ENTRY']) ?? []\n        playList.tracks = Array.prototype.map.call(playListTrackNodes,\n            (entry: Element, index: number) => {\n                const keyElement = entry.getElementsByTagName('PRIMARYKEY')[0]\n                const key = keyElement?.attributes.getNamedItem('KEY')?.value ?? ''\n                const track: PlaylistTrack = {\n                    key,\n                    collectionEntry: collection[key] as ArchiveTrack,\n                    playedPublic: true\n                }\n\n                const extendedData = entry.getElementsByTagName('EXTENDEDDATA')[0]\n                if (extendedData) {\n                    track.playedPublic = !!parseInt(extendedData.attributes.getNamedItem('PLAYEDPUBLIC')?.value ?? '1')\n                    const startTime = parseInt(extendedData.attributes.getNamedItem('STARTTIME')?.value ?? '0')\n                    track.startTime = NMLTimeToTime(startTime)\n                    const startDate = parseInt(extendedData.attributes.getNamedItem('STARTDATE')?.value ?? '0')\n                    track.startDate = NMLDateToDate(startDate)\n                    track.startTimeJS = new Date(\n                        track.startDate.year,\n                        track.startDate.month,\n                        track.startDate.day,\n                        track.startTime.hours,\n                        track.startTime.minutes,\n                        track.startTime.seconds\n                    )\n                } \n                return track\n            })\n        \n        return playList\n    })\n}\n\nclass CTraktorPlaylist extends CPlaylist {\n    filter(startIndex: number, playedLive: boolean) {\n        const result = super.filter(startIndex, playedLive)\n        computeTrackOffsets(result)\n        return result\n    }\n}\n\n/**\n * If extendeddata attributes are present in the playlist, computes the offset\n * that the track started at in [HH:]MM:SS format.\n * \n * @param {PlayList} playList \n */\nfunction computeTrackOffsets(playList: Playlist) {\n    const firstTrack = playList.tracks[0]\n    const lastTrack = playList.tracks[playList.tracks.length - 1]\n\n    if (firstTrack && lastTrack && firstTrack?.startTimeJS && lastTrack?.startTimeJS) {\n        const start = firstTrack.startTimeJS.getTime()\n        const lastTime = lastTrack.startTimeJS.getTime()\n        const hasHours = NMLTimeToTime((lastTime - start) / 1000).hours > 0\n        \n        playList.tracks.forEach((track: PlaylistTrack) => {\n            if (track.startTimeJS) {\n                track.timeOffset = (track.startTimeJS.getTime() - start) / 1000\n                track.timeOffsetString = timeString(track.timeOffset, !hasHours)\n            }\n        })\n    }\n}\n\ntype NMLDateValue = number\n\ntype NMLDate = {\n    year: number\n    month: number\n    day: number\n}\n\n// Functions to parse EXTENDEDDATA STARTDATE \nfunction year (x: NMLDateValue): number { return x >> 16 }\nfunction month(x: NMLDateValue): number { return (x >> 8) % 256 }\nfunction day  (x: NMLDateValue): number { return x % 256 }\n\nfunction NMLDateToDate(nmlDate: NMLDateValue): NMLDate {\n    return {\n        year: year(nmlDate),\n        month: month(nmlDate),\n        day: day(nmlDate)\n    }\n}\n// function DateToNMLDate(date: NMLDate): NMLDateValue {\n//     return date.year * 2**16 + date.month * 2**8 + date.day\n// }\n\n// Functions to parse EXTENDEDDATA STARTTIME \ntype NMLTimeValue = number\n\ntype NMLTime = {\n    hours: number\n    minutes: number\n    seconds: number\n}\n\nfunction seconds(t: NMLTimeValue): number { return t % 60 }\nfunction minutes(t: NMLTimeValue): number { return Math.floor((t - 3600*Math.floor(t/3600))/60) }\nfunction hours(t: NMLTimeValue): number { return Math.floor(t/3600) }\n\nfunction timeString(t: NMLTimeValue, stripHours: boolean): string {\n    const HH = hours(t).toString().padStart(2, '0')\n    const MM = minutes(t).toString().padStart(2, '0')\n    const SS = seconds(t).toString().padStart(2, '0')\n    if (stripHours) {\n        return `${MM}:${SS}`\n    } else {\n        return `${HH}:${MM}:${SS}`\n    }\n}\n\nfunction NMLTimeToTime(nmlTime: NMLTimeValue): NMLTime {\n    return {\n        hours: hours(nmlTime),\n        minutes: minutes(nmlTime),\n        seconds: seconds(nmlTime)\n    }\n}\n","import { Archive, ArchiveTrack, Collection, CPlaylist, Parser, PlaylistTrack } from \"./archive\"\nimport { querySelectorAllParents } from \"./common\"\n\nexport class RekordBoxParser implements Parser {\n    static format = \"RekordBox\"\n    static extensions = ['.xml']\n    xmlDoc: XMLDocument | null\n\n    constructor(contents:string) {\n        this.xmlDoc = RekordBoxParser.parseXML(contents)\n        if (this.xmlDoc) {\n            const root = this.xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n            if (root.length === 0) {\n                this.xmlDoc = null\n            }\n        }\n    }\n\n    private static parseXML(contents: string) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports():boolean {\n        return this.xmlDoc !== null\n    }\n    \n    parse():Archive|null {\n        if (!this.xmlDoc) {\n            return null\n        }\n\n        return parseRekordBox(this.xmlDoc)\n    }  \n}\n\nfunction parseRekordBox(xmlDoc:XMLDocument) {\n    const rekordBoxRoot = xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n    if (!rekordBoxRoot.length) {\n        return null\n    }\n\n    const archive = {\n        collection: parseCollection(xmlDoc),\n        playlists: [],\n        format: 'RekordBox'\n    }\n    archive.playlists = parsePlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\nfunction parseCollection(xmlDoc:XMLDocument) {\n    // Selector we are simulating 'DJ_PLAYLISTS > COLLECTION > TRACK'\n    const tracks = querySelectorAllParents(xmlDoc, ['DJ_PLAYLISTS', 'COLLECTION', 'TRACK'])\n    \n    const collection = Array.prototype.map.call(tracks,\n        (entry:Element, index:number) => {\n            return { \n                key: entry.attributes.getNamedItem('TrackID')?.value, \n                title: entry.attributes.getNamedItem('Name')?.value, \n                artist: entry.attributes.getNamedItem('Artist')?.value\n            }\n        })\n        .reduce((collection:Collection, track:ArchiveTrack) => {\n            collection[track.key] = track; return collection\n        }, {})\n    \n        return collection\n}\n\nfunction parsePlaylists(xmlDoc: XMLDocument, collection: Collection) {\n    const playlistNodes = xmlDoc.querySelectorAll(\"NODE[Type='1']\")\n\n    return Array.prototype.map.call(playlistNodes, (playlistNode:Element) => {\n        const name = playlistNode.attributes.getNamedItem('Name')?.value || ''\n        const playList = new CPlaylist(name, [])\n\n        playList.tracks = Array.prototype.map.call(playlistNode.getElementsByTagName('TRACK'),\n            (entry: Element, index: number) => {\n                const key = entry.attributes.getNamedItem('Key')?.value ?? ''\n                const track:PlaylistTrack = {\n                    key: key,\n                    playedPublic: true,\n                    collectionEntry: collection[key] as ArchiveTrack\n                }\n                return track\n            })\n        \n        return playList\n    })\n}","import {Parser, Archive, Playlist, PlaylistTrack, ArchiveTrack, CPlaylist} from './archive'\nimport {lineReader} from './common'\n\n// https://wiki.hydrogenaud.io/index.php?title=Cue_sheet\nexport class CUEParser implements Parser {\n    static format = \"RekordBox CUE\"\n    static extensions = ['.cue']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n\n    supports(): boolean {\n        // Not the best, file doesn't actually have to havce this but RekordBox\n        // does output the REM DATE.\n        return this.contents.startsWith('REM DATE ')\n    }\n    \n    parse(): Archive | null {\n        return cueParser(this.contents)\n    }\n}\n\nexport class Command {\n    data:string \n    \n    constructor(data:string) {\n        this.data = data\n    }\n\n    get name():string {\n        const match = /(\\w+)(\\s|$)/g.exec(this.data)\n        if (match?.[1]) {\n            return match[1].toUpperCase()\n        }\n        return ''\n    }\n\n    stringParam() :string|undefined {\n        // Quoted Strings\n        const QUOTED = /^\\s*(\\w+)\\s\"(.*)\"/\n        let match = QUOTED.exec(this.data)\n        if (match?.[2]) {\n            return match[2]\n        }\n        // Embedded Quotes\n        match = /^\\s*\\w+\\s(.*)$/.exec(this.data)\n        if (match?.[1]) {\n            return match[1]\n        }\n        return undefined\n    }\n    param(index:number): string|undefined {\n        const lines = this.data.split(' ')\n        return lines[index]\n    }\n}\n\ntype Context = {\n    archive: Archive,\n    header: HeaderState\n}\n\ninterface State {\n    onCommand(context: Context, command:Command): void\n    onNextState(context: Context, command:Command): State\n}\n\nclass HeaderState implements State {\n    title: string|undefined\n    performer: string|undefined\n\n    onCommand(context: Context, command: Command): void {\n        switch (command.name) {\n            case 'TITLE':\n                this.title = command.stringParam()\n                break\n            case 'PERFORMER':\n                this.performer = command.stringParam()\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'FILE') {\n            return new PlaylistState()\n        }\n        return this\n    }\n}\n\nclass PlaylistState implements State {\n    onCommand(context: Context, command: Command): void {\n        const nameFields = [context.header.title, context.header.performer]\n            .filter((field) => field)\n        const playlist: Playlist = new CPlaylist(nameFields.join(' - '))\n\n        context.archive.playlists.push(playlist)\n    } \n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nclass TrackState implements State {\n    id: string\n\n    constructor(context:Context, id:string|undefined) {\n        this.id = id  ?? '' + Math.random()\n        const collectionTrack:ArchiveTrack = {\n            key: this.id,\n            title: '',\n            artist: ''\n        }\n        const playlist = context.archive.playlists[context.archive.playlists.length - 1]\n        const playlistTrack: PlaylistTrack = {\n            key: collectionTrack.key,\n            collectionEntry: collectionTrack,\n            playedPublic: true\n        }\n        playlist?.tracks.push(playlistTrack)\n    context.archive.collection[collectionTrack.key] = collectionTrack\n    }\n\n    playlist(context: Context, ): Playlist {\n        return context.archive.playlists[context.archive.playlists.length - 1] as Playlist\n    }\n\n    playlistTrack(context: Context, ): PlaylistTrack {\n        const playlist: Playlist = this.playlist(context)\n        return playlist.tracks[playlist.tracks.length - 1] as PlaylistTrack\n    }\n\n    collectionTrack(context: Context, ): ArchiveTrack {\n        const playlistTrack = this.playlistTrack(context)\n        return context.archive.collection[playlistTrack.key] as ArchiveTrack\n    }\n\n    onCommand(context: Context, command: Command): void {\n        const collectionTrack = this.collectionTrack(context)\n\n        switch (command.name) {\n            case 'TITLE':\n                collectionTrack.title = command.stringParam() ?? ''\n                break\n            case 'PERFORMER':\n                collectionTrack.artist = command.stringParam() ?? ''\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nexport function cueReader(contents:string, cb:(command:Command) => void) {\n    lineReader(contents, (commandString:string, index:number) => {\n        const command:Command = new Command(commandString)\n        cb(command)\n    })\n}\n\nexport function cueParser(contents:string):Archive {\n    let state:State = new HeaderState()\n    const context:Context = {\n        archive:{\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive,\n        header: state as HeaderState\n    }\n\n    cueReader(contents, (command:Command) => {\n        state.onCommand(context, command)\n        state = state = state.onNextState(context, command)\n    })\n\n    return context.archive\n}","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\ntype Headers = {[n: string]: number}\n\nexport class RekordBoxTXTParser implements Parser {\n    static format = \"RekordBox TXT\"\n    static extensions = ['.txt']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n    supports(): boolean {\n        return this.contents.trim().startsWith('#\\t')\n    }\n    \n    parse(): Archive | null {\n        const archive = {\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive\n        const playlist: Playlist = new CPlaylist()\n\n        textReader(this.contents, (archiveTrack:ArchiveTrack) => {\n            const playlistTrack: PlaylistTrack = {\n                key: archiveTrack.key,\n                collectionEntry: archiveTrack,\n                playedPublic: true\n            }\n            archive.collection[archiveTrack.key] = archiveTrack\n            if (!playlist.tracks.length) {\n                archive.playlists.push(playlist)\n            }\n            playlist.tracks.push(playlistTrack)\n        })\n\n        return archive\n    }\n}\n\nconst TXT_MAP = {\n    TITLE: 'TRACK TITLE',\n    ARTIST: 'ARTIST',\n    KEY: '#'\n}\n\nfunction getField(name:string, headers:Headers, fields: Array<string>): string|null {\n    const fieldIndex = headers[name]\n\n    if (fieldIndex !== undefined && fields[fieldIndex]) {\n        return fields[fieldIndex] as string\n    }\n    return null\n}\n\nfunction textReader(contents:string, cb:(track:ArchiveTrack) => void) {\n    let headers: Headers = {}\n\n    lineReader(contents, (line:string, index:number) => {\n        const fields = line.split('\\t')\n\n        if (index === 0) {\n            headers = fields.reduce((headers:Headers, cur:string, index:number) => {\n                headers[cur.toUpperCase()] = index\n                return headers\n            }, headers)\n        } else {\n            cb({\n                key: getField(TXT_MAP.KEY, headers, fields) ?? `${Math.random()}`,\n                title: getField(TXT_MAP.TITLE, headers, fields) ?? '',\n                artist: getField(TXT_MAP.ARTIST, headers, fields) ?? ''\n            })\n        }\n    })\n}","import { Playlist } from \"./parsers/archive\"\n\nexport const DEFAULT_FORMAT_STRING = '${INDEX}. ${TITLE} - ${ARTIST}'\n\nexport const TRACK_FIELDS = {\n    INDEX: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${INDEX}', `${trackIndex + 1}`)\n    },\n    INDEX_PADDED: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const padding = playList.tracks.length.toString().length\n        return formatString.replace('${INDEX_PADDED}', (trackIndex + 1).toString().padStart(padding, '0'))\n    },\n    TITLE: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${TITLE}', playList.tracks?.[trackIndex]?.collectionEntry.title || 'Unknown Title')\n    },\n    ARTIST: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${ARTIST}', playList.tracks?.[trackIndex]?.collectionEntry.artist || 'Unknown Artist')\n    },\n    OFFSET: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const substitution = playList.tracks[trackIndex]?.timeOffsetString ?? ''\n        return formatString.replace('${OFFSET}', substitution)\n    }\n}\n\nexport function format(playList:Playlist, trackIndex:number, formatString:string): string {\n    Object.values(TRACK_FIELDS).forEach((trackKey) => { \n        formatString = trackKey(playList, trackIndex, formatString)\n    })\n    return formatString\n}\n\n\n/**\n * Converts a playlist to a human readable form.\n * \n * @param {Playlist} playlist  Playlist to turn into a human readable string.\n */\nexport function playlistToReadable(playlist:Playlist, FORMAT_STRING:string): string {\n    const result = []\n\n    result.push(playlist.name)\n\n    playlist.tracks\n        .map((track, index) => result.push(format(playlist, index, FORMAT_STRING)))\n\n    return result.join('\\n')\n}\n","import { TraktorParser } from './parsers/traktor'\nimport { RekordBoxParser } from './parsers/rekordbox'\nimport { M3U8Parser } from './parsers/m3u8'\nimport { CUEParser } from './parsers/cue'\nimport {RekordBoxTXTParser} from './parsers/rekordboxtxt'\nimport {DEFAULT_FORMAT_STRING, playlistToReadable, TRACK_FIELDS} from './formatter'\nimport { Playlist } from './parsers/archive'\n\n/**\n * HACK - TypeScript errors out on every possible null value from\n * getElementbyId so we use this to ignore it and let the app crash at runtime.\n */\n function getElementById<T = HTMLElement>(id: string): T {\n    return document.getElementById(id) as T\n}\n\nconst PARSERS = [TraktorParser, RekordBoxParser, M3U8Parser, CUEParser, RekordBoxTXTParser]\n\nfunction getFormatString() {\n    const formatStringInput = getElementById<HTMLInputElement>('formatString')\n    let formatString = formatStringInput.value\n    if (formatString.length === 0) {\n        formatString = DEFAULT_FORMAT_STRING\n    }\n    return formatString\n}\n\n/**\n * Parses the uploaded file contents with the first matching parser, returning\n * the archive in canonical JSON format.\n * \n * @param {string} fileContents  Archive file contents.\n * @return Archive if parsed, otherwise null.\n */\n function parseArchive(fileContents: string) {\n    for (let parserClass of PARSERS) {\n        const parser = new parserClass(fileContents)\n        if (parser.supports()) {\n            return parser.parse()\n        }\n    }\n\n    return null\n}\n\nfunction convertToReadable(fileContents: string) {\n    hideErrorResult()\n    hidePlaylistResults()\n\n    const archive = parseArchive(fileContents)\n\n    if (!archive) {\n        showErrorResult('Sorry, we could not parse that file.')\n        const trackListElements = getElementById('trackList')\n        trackListElements.innerText = \"No playlists found.\"\n        return\n    }\n    \n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    dropDown.replaceChildren('')\n    archive.playlists.forEach((playlist, index) => {\n        const option = document.createElement('option')\n        if (playlist.name.trim().length) {\n            option.innerText = playlist.name\n        } else {\n            option.innerText = `Playlist ${index + 1}`\n        }\n        (option as any).playlist = playlist\n        dropDown.appendChild(option)\n    })\n    \n    showPlaylistResults()\n    updateSelectedPlaylist()\n}\n\nfunction hidePlaylistResults() {\n    const div = getElementById('playlistResults')\n    div.setAttribute('class', 'hidden')\n}\n\nfunction showPlaylistResults() {\n    const div = getElementById('playlistResults')\n    div.setAttribute('class', '')\n}\n\nfunction hideErrorResult() {\n    const div = getElementById('errorResults')\n    div.setAttribute('class', 'hidden')\n}\nfunction showErrorResult(errorMessage: string) {\n    const div = getElementById('errorResults')\n    div.setAttribute('class', '')\n    const errorMessageElement = getElementById('errorMessage')\n    errorMessageElement.innerText = errorMessage\n}\n\nfunction updateSelectedPlaylist() {\n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    const selectedOption = dropDown.selectedOptions[0]\n    let startTrackIndex: number = parseInt(getElementById<HTMLInputElement>('startTrackIndex').value) || 1\n    startTrackIndex = Math.max(1, startTrackIndex - 1)\n    const onlyPlayedTracks = getElementById<HTMLInputElement>('publicTracks')\n    const playlist: Playlist = (selectedOption as any).playlist as Playlist\n    const filteredPlaylist = playlist.filter(startTrackIndex, onlyPlayedTracks.checked)\n    getElementById('trackList').textContent = playlistToReadable(filteredPlaylist, getFormatString())\n}\n\nfunction uploadTracklist(e: Event) {XMLHttpRequestEventTarget\n    const fileElement = e.target as HTMLInputElement\n    const file = fileElement?.files?.[0]\n    if (!file) {\n        return\n    }\n    const reader = new FileReader()\n\n    reader.readAsText(file)\n    reader.onload = function () {\n        const newArchiveText: string = reader?.result?.toString() ?? ''\n        convertToReadable(newArchiveText)\n    }\n    // If you upload the same file twice the second upload won't trigger\n    // this function.  Clearing the value fixes this.\n    fileElement.value = ''\n}\n\nfunction copyToClipboard() {\n    const trackListElement = getElementById('trackList')\n    const copyText = trackListElement.innerText\n    navigator.clipboard.writeText(copyText)\n}\n\nfunction saveToTxtFile() {\n    const trackListElement = getElementById('trackList')\n    const copyText = trackListElement.innerText\n    const blob = new Blob([copyText], {type: \"text/plain;charset=utf-8\"});\n    let playlistName = '' as string\n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    const selectedOption = dropDown.selectedOptions[0]\n    if (selectedOption) {\n        playlistName = selectedOption.innerText + '.txt'\n    } else {\n        playlistName = 'playlist.txt'\n    }\n    saveAs(blob, playlistName);\n}\n\nfunction saveAs(blob: Blob, fileName: string) {\n    const link = document.createElement(\"a\");\n    link.download = fileName\n    link.href = URL.createObjectURL(blob);\n    link.click();\n}\n\nwindow.addEventListener('DOMContentLoaded', () => {\n    getElementById('archiveFile').addEventListener(\"change\", uploadTracklist, false)\n    getElementById('formatString').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('startTrackIndex').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('publicTracks').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('copyToClipboard').addEventListener(\"click\", copyToClipboard, false)\n    getElementById('saveToTxtFile').addEventListener(\"click\", saveToTxtFile, false)\n    getElementById('playlistsDropDown').addEventListener('change', updateSelectedPlaylist, false)\n    \n    const fieldList = Object.keys(TRACK_FIELDS)\n        .map((fieldName) => `\\${${fieldName}}`)\n        .join(' ')\n    const fieldListElement = getElementById('fieldList') \n        fieldListElement.textContent =\n        fieldListElement.textContent + fieldList\n\n    const extensions = PARSERS.map((parser) => parser.extensions ).flat()\n    const uploadInput = getElementById<HTMLInputElement>('archiveFile')\n    uploadInput.accept = extensions.join(',')\n});\n\n\n","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\nexport class M3U8Parser implements Parser {\n    static format = \"RekordBox M3U8\"\n    static extensions = ['.m3u8']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n\n    supports(): boolean {\n        return this.contents.startsWith('#EXTM3U')\n    }\n    \n    parse(): Archive | null {\n        return parseM3U8(this.contents)\n    }  \n}\n\nfunction parseM3U8(\n    contents: string) {\n    if (!contents.startsWith('#EXTM3U')) {\n        return null\n    }\n    const archive: Archive = {\n        collection: {},\n        playlists: [] as Array<Playlist>,\n        format: 'M3U'\n    }\n    const playlist = new CPlaylist('Untitled Playlist')\n    archive.playlists.push(playlist)\n    \n    let currentArchiveTrack: ArchiveTrack | undefined\n    let currentTrack: PlaylistTrack | undefined\n\n    lineReader(contents, (line) => {\n        const regex = /^#EXTINF:(\\d+),(([^-]*$)|(.*)( - )(.*))/g\n        const match:RegExpExecArray|null = regex.exec(line)\n\n        if (match && match[1]) {\n            currentArchiveTrack = {\n                key: '__TEMP__',\n                title: match[6] || match[3] || '',\n                artist: match[4] || ''\n            }\n            currentTrack = {\n                key: currentArchiveTrack.key,\n                playedPublic: true,\n                collectionEntry: currentArchiveTrack\n            }\n        } else if (currentTrack && currentArchiveTrack) {\n            const key:string = line\n\n            // The line after the EXTINF has the file path which we use as our\n            // unique key as the integer after EXTINF is not sufficient.\n            currentArchiveTrack.key = key\n            currentTrack.key = key\n\n            archive.collection[key] = currentArchiveTrack\n            playlist.tracks.push(currentTrack)\n        }\n    })\n    return archive\n}\n"],"names":["$657abdbdcf4245f0$export$807e79111d5cf0eb","constructor","name","tracks","this","filter","startIndex","playedLive","result","_","index","track","playedPublic","$34fb56a4ecb7eab0$export$5087fc42c9e3571c","contents","cb","split","forEach","line","trim","length","$34fb56a4ecb7eab0$export$4303e24c56c34701","xmlDoc","parents","tagName","shift","isLastTag","children","querySelectorAll","$7bcb0e88a8caa2ba$export$2027af7c5cd3a36c","static","parseXML","getElementsByTagName","DOMParser","parseFromString","supports","parse","archive","collection","$7bcb0e88a8caa2ba$var$nmlCollection","playlists","format","playlistNodes","Array","prototype","map","call","playlistNode","playList","$7bcb0e88a8caa2ba$var$CTraktorPlaylist","attributes","getNamedItem","value","playListTrackNodes","entry","key","collectionEntry","extendedData","parseInt","startTime","$7bcb0e88a8caa2ba$var$NMLTimeToTime","startDate","year","$7bcb0e88a8caa2ba$var$year","nmlDate","month","$7bcb0e88a8caa2ba$var$month","day","$7bcb0e88a8caa2ba$var$day","startTimeJS","Date","hours","minutes","seconds","$7bcb0e88a8caa2ba$var$nmlPlaylists","$7bcb0e88a8caa2ba$var$parseTraktor","collectionEntries","location","title","artist","reduce","super","firstTrack","lastTrack","start","getTime","hasHours","timeOffset","timeOffsetString","t","stripHours","HH","$7bcb0e88a8caa2ba$var$hours","toString","padStart","MM","$7bcb0e88a8caa2ba$var$minutes","SS","$7bcb0e88a8caa2ba$var$seconds","$7bcb0e88a8caa2ba$var$timeString","$7bcb0e88a8caa2ba$var$computeTrackOffsets","x","Math","floor","nmlTime","$cf173d13f3653799$export$5bbeb5f972cff134","$cf173d13f3653799$var$parseCollection","$cf173d13f3653799$var$parsePlaylists","$cf173d13f3653799$var$parseRekordBox","$d5b03de8161447d4$export$cc7e12c76513e857","data","match","exec","toUpperCase","stringParam","param","$d5b03de8161447d4$var$HeaderState","onCommand","context","command","performer","onNextState","$d5b03de8161447d4$var$PlaylistState","nameFields","header","field","playlist","join","push","$d5b03de8161447d4$var$TrackState","id","random","collectionTrack","playlistTrack","$1aa7d39bd7258560$var$TXT_MAP","$1aa7d39bd7258560$var$getField","headers","fields","fieldIndex","undefined","$f6cce17ab644ef19$export$54dbb75bbd456ec6","INDEX","trackIndex","formatString","replace","INDEX_PADDED","padding","TITLE","ARTIST","OFFSET","substitution","$f6cce17ab644ef19$export$eac847f019cd2b46","FORMAT_STRING","Object","values","trackKey","$b4e14b6b8da86996$var$getElementById","document","getElementById","$b4e14b6b8da86996$var$PARSERS","startsWith","currentArchiveTrack","currentTrack","$7836064f439eaf5e$var$parseM3U8","state","commandString","$d5b03de8161447d4$export$c32dec9fe4d709a2","$d5b03de8161447d4$export$afaa313fa0c73604","cur","$1aa7d39bd7258560$var$textReader","archiveTrack","$b4e14b6b8da86996$var$convertToReadable","fileContents","setAttribute","parserClass","parser","$b4e14b6b8da86996$var$parseArchive","errorMessage","innerText","$b4e14b6b8da86996$var$showErrorResult","dropDown","replaceChildren","option","createElement","appendChild","$b4e14b6b8da86996$var$updateSelectedPlaylist","selectedOption","selectedOptions","startTrackIndex","max","onlyPlayedTracks","filteredPlaylist","checked","textContent","$b4e14b6b8da86996$var$getFormatString","$b4e14b6b8da86996$var$uploadTracklist","e","XMLHttpRequestEventTarget","fileElement","target","file","files","reader","FileReader","readAsText","onload","$b4e14b6b8da86996$var$copyToClipboard","copyText","navigator","clipboard","writeText","$b4e14b6b8da86996$var$saveToTxtFile","blob","Blob","type","playlistName","fileName","link","download","href","URL","createObjectURL","click","$b4e14b6b8da86996$var$saveAs","window","addEventListener","fieldList","keys","fieldName","fieldListElement","extensions","flat","accept"],"version":3,"file":"index.9c76649e.js.map"}