{"mappings":"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","sources":["src/archive.ts","src/traktor.js","src/rekordbox.js","src/common.ts","src/cue.ts","src/rekordboxtxt.ts","src/formatter.ts","src/index.js","src/m3u8.ts"],"sourcesContent":["export interface ArchiveTrack {\n    key: string\n    title: string\n    artist: string\n}\nexport interface PlayedTime {\n    hours: number\n    minutes: number\n    seconds: number\n}\nexport interface PlayedDate {\n    year: number\n    month: number\n    day: number\n}\nexport interface PlaylistTrack {\n    key: string\n    collectionEntry: ArchiveTrack\n    playedPublic: boolean\n    startTime?: PlayedTime\n    startDate?: PlayedDate\n    startTimeJS?: Date\n    timeOffset?: number\n    timeOffsetString?: string\n}\nexport interface Playlist {\n    name: string\n    tracks: Array<PlaylistTrack>\n\n    filter(startIndex: number, playedLive: boolean): Playlist\n}\nexport interface Archive {\n    collection: { [n: string]: ArchiveTrack }\n    playlists: Array<Playlist>\n    format: string\n}\n\nexport interface Parser {    \n    supports(contents:string): boolean\n    parse(\n        contents: string, \n        startTrackIndex: number, \n        onlyPlayedTracks: boolean) : Archive | null\n}\n\nexport class CPlaylist implements Playlist {\n    name:string \n    tracks: Array<PlaylistTrack>\n\n    constructor(name:string = '', tracks: Array<PlaylistTrack> = []) {\n        this.name = name\n        this.tracks = tracks\n    }\n\n    filter(startIndex: number, playedLive: boolean): Playlist {\n        let result = new CPlaylist()\n        result.name = this.name\n        result.tracks = this.tracks\n            .filter((_, index) => index >= (startIndex))\n            .filter((track) => playedLive ? track.playedPublic : true)\n\n        return result\n    }\n}\n","import { CPlaylist } from \"./archive\"\n\nexport class TraktorParser {\n    static format = \"Traktor\"\n    static extensions = ['.nml']\n\n    parseXML(contents) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports(contents) {\n        const xmlDoc = this.parseXML(contents)\n\n        if (!xmlDoc) {\n            return false\n        }\n        const root = xmlDoc.getElementsByTagName(\"NML\")\n        return root.length > 0\n    }\n    \n    parse(contents) {\n        const xmlDoc = this.parseXML(contents)\n\n        if (!xmlDoc) {\n            return null\n        }\n\n        return parseTraktor(xmlDoc)\n    }  \n}\n\nfunction parseTraktor(xmlDoc) {\n    const archive = {\n        collection: nmlCollection(xmlDoc),\n        playlists: [],\n        format: 'Traktor NML'\n    }\n    archive.playlists = nmlPlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\n/**\n * Returns the NML COLLECTION as a map from track KEY to a track object which has shape\n * {title:'track name', artist:'Artist', key:'UID'} for every unique track that appears in \n * any of the playlists in the file. The track key is built from it's LOCATION node\n * which is used to map to Playlist items.\n * \n * @param {XMLDocument} xmlDoc \n * @returns Map of track keys to collection item.\n */\nfunction nmlCollection(xmlDoc) {\n    return Array.prototype.map.call(xmlDoc\n        .querySelectorAll(\"NML > COLLECTION > ENTRY\"),\n        (entry, index) => {\n            const track = { \n                title: entry.attributes['TITLE']?.value, \n                artist: entry.attributes['ARTIST']?.value\n            }\n            const location = entry.querySelectorAll('LOCATION')[0]\n            track.key = location.attributes['VOLUME'].value +\n                location.attributes['DIR'].value +\n                location.attributes['FILE'].value\n            track.key = track.key\n            return track\n        })\n        .reduce((collection, track) => {collection[track.key] = track; return collection}, {})\n}\n\n/**\n * Returns an array of playlists that are present in the NML.  Each entry is an object\n * with shape shown below.  The order of the `tracks` array is the order in which the\n * tracks were sorted in the Traktor UI. `startTrackIndex` is useful when your playlist\n * has a ton of tracks you previewed before you went live.  None of them wound up \n * in the mix so you don't want them in your playlist.  You'd think you could\n * just delete these in Traktor Explorer -> Archive -> History but no.\n *\n * {\n *   name: 'My Playlist',\n *   tracks: [{\n *       key: 'track_key'\n *       // Only if EXTENDEDDATA present.\n *       startTime: 123\n *       startDate: 1234\n *       playedPublic: true\n *     },\n *     ...\n *   ]\n * }\n * \n * @param {XMLDocument} xmlDoc\n * @param {Collection} Collection from nmlCollection(xmlDoc)\n * @returns Array of playlists.\n */\nfunction nmlPlaylists(xmlDoc, collection) {\n    const playlistNodes = xmlDoc.querySelectorAll(\"NML PLAYLISTS NODE[TYPE='PLAYLIST']\")\n\n    var playlists = Array.prototype.map.call(playlistNodes, (playlistNode) => {\n        const playList = new CTraktorPlaylist(\n            playlistNode.attributes['NAME']?.value,\n            []\n        )\n        playList.tracks = Array.prototype.map.call(playlistNode.querySelectorAll('PLAYLIST > ENTRY'),\n            (entry, index) => {\n                const track = { }\n                const key = entry.getElementsByTagName('PRIMARYKEY')[0]\n                track.key = key.attributes['KEY'].value\n                track.collectionEntry = collection[track.key]\n\n                const extendedData = entry.getElementsByTagName('EXTENDEDDATA')[0]\n                if (extendedData) {\n                    track.playedPublic = !!parseInt(extendedData.attributes['PLAYEDPUBLIC'].value)\n                    const startTime = parseInt(extendedData.attributes['STARTTIME'].value)\n                    track.startTime = NMLTimeToTime(startTime)\n                    const startDate = parseInt(extendedData.attributes['STARTDATE'].value)\n                    track.startDate = NMLDateToDate(startDate)\n                    track.startTimeJS = new Date(\n                        track.startDate.year,\n                        track.startDate.month,\n                        track.startDate.day,\n                        track.startTime.hours,\n                        track.startTime.minutes,\n                        track.startTime.seconds\n                    )\n                } else {\n                    track.playedPublic = true\n                }\n                return track\n            })\n        \n        return playList\n    })\n    return playlists\n}\n\nclass CTraktorPlaylist extends CPlaylist {\n    filter(startIndex, playedLive) {\n        const result = super.filter(startIndex, playedLive)\n        computeTrackOffsets(result)\n        return result\n    }\n}\n\n/**\n * If extendeddata attributes are present in the playlist, computes the offset\n * that the track started at in [HH:]MM:SS format.\n * \n * @param {PlayList} playList \n */\nfunction computeTrackOffsets(playList) {\n    // Don't compute if EXTENDEDDATA does not exist\n    if (!playList.tracks[0]?.startTimeJS) {\n        return\n    }\n\n    const start = playList.tracks[0].startTimeJS\n    const lastTime = playList.tracks[playList.tracks.length - 1].startTimeJS\n    // TOOD - Use startTimeJS\n    const hasHours = NMLTimeToTime((lastTime - start) / 1000).hours > 0\n    const hasHoursTest = 0 < Math.floor((lastTime - start) / 3600 / 1000)\n    console.assert(hasHours === hasHoursTest, `${hasHours} === ${hasHoursTest}`)\n    \n    playList.tracks.forEach((track) => {\n        track.timeOffset = (track.startTimeJS - start) / 1000\n        track.timeOffsetString = timeString(track.timeOffset, !hasHours)\n    })\n}\n\n\n// Functions to parse EXTENDEDDATA STARTDATE \nfunction year(x) { return x >> 16 }\nfunction month(x) { return (x >> 8) % 256 }\nfunction day(x) { return x % 256 }\n\nfunction NMLDateToDate(nmlDate) {\n    return {\n        year: year(nmlDate),\n        month: month(nmlDate),\n        day: day(nmlDate)\n    }\n}\nfunction DateToNMLDate(date) {\n    return date.year * 2**16 + date.month * 2**8 + date.day\n}\n\n// Functions to parse EXTENDEDDATA STARTTIME \nfunction seconds(t) { return t % 60 }\nfunction minutes(t) { return Math.floor((t - 3600*Math.floor(t/3600))/60) }\nfunction hours(t) { return Math.floor(t/3600) }\n\nfunction timeString(t, stripHours) {\n    const HH = hours(t).toString().padStart(2, '0')\n    const MM = minutes(t).toString().padStart(2, '0')\n    const SS = seconds(t).toString().padStart(2, '0')\n    if (stripHours) {\n        return `${MM}:${SS}`\n    } else {\n        return `${HH}:${MM}:${SS}`\n    }\n}\n\nfunction NMLTimeToTime(nmlTime) {\n    return {\n        hours: hours(nmlTime),\n        minutes: minutes(nmlTime),\n        seconds: seconds(nmlTime)\n    }\n}\n","import { CPlaylist } from \"./archive\"\n\nexport class RekordBoxParser {\n    static format = \"RekordBox\"\n    static extensions = ['.xml']\n\n    parseXML(contents) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports(contents) {\n        const xmlDoc = this.parseXML(contents)\n\n        if (!xmlDoc) {\n            return false\n        }\n        const rekordBoxRoot = xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n        return rekordBoxRoot.length > 0\n    }\n    \n    parse(contents) {\n        const xmlDoc = this.parseXML(contents)\n\n        if (!xmlDoc) {\n            return null\n        }\n\n        return parseRekordBox(xmlDoc)\n    }  \n}\n\nfunction parseRekordBox(xmlDoc) {\n    const rekordBoxRoot = xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n    if (!rekordBoxRoot.length) {\n        return null\n    }\n\n    const archive = {\n        collection: parseCollection(xmlDoc),\n        playlists: [],\n        format: 'RekordBox'\n    }\n    archive.playlists = parsePlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\nfunction parseCollection(xmlDoc) {\n    const tracks = xmlDoc\n        .getElementsByTagName('DJ_PLAYLISTS')[0]\n        .getElementsByTagName(\"COLLECTION\")[0]\n        .getElementsByTagName(\"TRACK\")\n    \n    const collection = Array.prototype.map.call(tracks,\n        (entry, index) => {\n            return { \n                key: entry.attributes['TrackID'].value, \n                title: entry.attributes['Name'].value, \n                artist: entry.attributes['Artist'].value\n            }\n        })\n        .reduce((collection, track) => {collection[track.key] = track; return collection}, {})\n    \n        return collection\n}\n\nfunction parsePlaylists(xmlDoc, collection) {\n    const playlistNodes = xmlDoc.querySelectorAll(\"DJ_PLAYLISTS > PLAYLISTS NODE[KeyType='0']\")\n\n    var playlists = Array.prototype.map.call(playlistNodes, (playlistNode) => {\n        const playList = new CPlaylist(playlistNode.attributes['Name'].value, [])\n        playList.tracks = Array.prototype.map.call(playlistNode.getElementsByTagName('TRACK'),\n            (entry, index) => {\n                const track = {\n                    key: entry.attributes['Key'].value,\n                    playedPublic: true\n                }\n                track.collectionEntry = collection[track.key]\n                return track\n            })\n        \n        return playList\n    })\n    return playlists\n}","export function lineReader(contents:string, cb: (line:string, index:number) => void): void {\n    const lines = contents.split('\\n')\n    lines.forEach((line, index) => {\n        line = line.trim()\n        if (line.length) {\n            cb(line, index)\n        }\n    })\n}\n","import {Parser, Archive, Playlist, PlaylistTrack, ArchiveTrack, CPlaylist} from './archive'\nimport {lineReader} from './common'\n\n// https://wiki.hydrogenaud.io/index.php?title=Cue_sheet\nexport class CUEParser implements Parser {\n    static format = \"RekordBox CUE\"\n    static extensions = ['.cue']\n    archive: Archive\n    playlist: Playlist\n\n    supports(contents: string): boolean {\n        // Not the best, file doesn't actually have to havce this but RekordBox\n        // does output the REM DATE.\n        return contents.startsWith('REM DATE ')\n    }\n    \n    parse(contents: string): Archive | null {\n        return cueParser(contents)\n    }\n}\n\nexport class Command {\n    data:string \n    \n    constructor(data:string) {\n        this.data = data\n    }\n\n    get name():string {\n        const match = /(\\w+)(\\s|$)/g.exec(this.data)\n        if (match?.[1]) {\n            return match[1].toUpperCase()\n        }\n        return ''\n    }\n\n    stringParam() :string|undefined {\n        // Quoted Strings\n        const QUOTED = /^\\s*(\\w+)\\s\"(.*)\"/\n        let match = QUOTED.exec(this.data)\n        if (match?.[2]) {\n            return match[2]\n        }\n        // Embedded Quotes\n        match = /^\\s*\\w+\\s(.*)$/.exec(this.data)\n        if (match?.[1]) {\n            return match[1]\n        }\n        return undefined\n    }\n    param(index:number): string|undefined {\n        const lines = this.data.split(' ')\n        return lines[index]\n    }\n}\n\ntype Context = {\n    archive: Archive,\n    header: HeaderState\n}\n\ninterface State {\n    onCommand(context: Context, command:Command): void\n    onNextState(context: Context, command:Command): State\n}\n\nclass HeaderState implements State {\n    title: string|undefined\n    performer: string|undefined\n\n    onCommand(context: Context, command: Command): void {\n        switch (command.name) {\n            case 'TITLE':\n                this.title = command.stringParam()\n                break\n            case 'PERFORMER':\n                this.performer = command.stringParam()\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'FILE') {\n            return new PlaylistState()\n        }\n        return this\n    }\n}\n\nclass PlaylistState implements State {\n    onCommand(context: Context, command: Command): void {\n        const nameFields = [context.header.title, context.header.performer]\n            .filter((field) => field)\n        const playlist: Playlist = new CPlaylist(nameFields.join(' - '))\n\n        context.archive.playlists.push(playlist)\n    } \n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nclass TrackState implements State {\n    id: string\n\n    constructor(context:Context, id:string|undefined) {\n        this.id = id  ?? '' + Math.random()\n        const collectionTrack:ArchiveTrack = {\n            key: this.id,\n            title: '',\n            artist: ''\n        }\n        const playlist = context.archive.playlists[context.archive.playlists.length - 1]\n        const playlistTrack: PlaylistTrack = {\n            key: collectionTrack.key,\n            collectionEntry: collectionTrack,\n            playedPublic: true\n        }\n        playlist?.tracks.push(playlistTrack)\n    context.archive.collection[collectionTrack.key] = collectionTrack\n    }\n\n    playlist(context: Context, ): Playlist {\n        return context.archive.playlists[context.archive.playlists.length - 1] as Playlist\n    }\n\n    playlistTrack(context: Context, ): PlaylistTrack {\n        const playlist: Playlist = this.playlist(context)\n        return playlist.tracks[playlist.tracks.length - 1] as PlaylistTrack\n    }\n\n    collectionTrack(context: Context, ): ArchiveTrack {\n        const playlistTrack = this.playlistTrack(context)\n        return context.archive.collection[playlistTrack.key] as ArchiveTrack\n    }\n\n    onCommand(context: Context, command: Command): void {\n        const collectionTrack = this.collectionTrack(context)\n\n        switch (command.name) {\n            case 'TITLE':\n                collectionTrack.title = command.stringParam() ?? ''\n                break\n            case 'PERFORMER':\n                collectionTrack.artist = command.stringParam() ?? ''\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nexport function cueReader(contents:string, cb:(command:Command) => void) {\n    lineReader(contents, (commandString:string, index:number) => {\n        const command:Command = new Command(commandString)\n        cb(command)\n    })\n}\n\nexport function cueParser(contents:string):Archive {\n    let state:State = new HeaderState()\n    const context:Context = {\n        archive:{\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive,\n        header: state as HeaderState\n    }\n\n    cueReader(contents, (command:Command) => {\n        state.onCommand(context, command)\n        state = state = state.onNextState(context, command)\n    })\n\n    return context.archive\n}","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\ntype Headers = {[n: string]: number}\n\nexport class RekordBoxTXTParser implements Parser {\n    static format = \"RekordBox TXT\"\n    static extensions = ['.txt']\n    archive: Archive\n    playlist: Playlist\n\n    supports(contents: string): boolean {\n        return contents.trim().startsWith('#\\t')\n    }\n    \n    parse(contents: string): Archive | null {\n        const archive = {\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive\n        const playlist: Playlist = new CPlaylist()\n\n        textReader(contents, (archiveTrack:ArchiveTrack) => {\n            const playlistTrack: PlaylistTrack = {\n                key: archiveTrack.key,\n                collectionEntry: archiveTrack,\n                playedPublic: true\n            }\n            archive.collection[archiveTrack.key] = archiveTrack\n            if (!playlist.tracks.length) {\n                archive.playlists.push(playlist)\n            }\n            playlist.tracks.push(playlistTrack)\n        })\n\n        return archive\n    }\n}\n\nconst TXT_MAP = {\n    TITLE: 'TRACK TITLE',\n    ARTIST: 'ARTIST',\n    KEY: '#'\n}\n\nfunction getField(name:string, headers:Headers, fields: Array<string>): string|null {\n    const fieldIndex = headers[name]\n\n    if (fieldIndex !== undefined && fields[fieldIndex]) {\n        return fields[fieldIndex] as string\n    }\n    return null\n}\n\nfunction textReader(contents:string, cb:(track:ArchiveTrack) => void) {\n    let headers: Headers = {}\n\n    lineReader(contents, (line:string, index:number) => {\n        const fields = line.split('\\t')\n\n        if (index === 0) {\n            headers = fields.reduce((headers:Headers, cur:string, index:number) => {\n                headers[cur.toUpperCase()] = index\n                return headers\n            }, headers)\n        } else {\n            cb({\n                key: getField(TXT_MAP.KEY, headers, fields) ?? `${Math.random()}`,\n                title: getField(TXT_MAP.TITLE, headers, fields) ?? '',\n                artist: getField(TXT_MAP.ARTIST, headers, fields) ?? ''\n            })\n        }\n    })\n}","import { Playlist } from \"./archive\"\n\nexport const DEFAULT_FORMAT_STRING = '${INDEX}. ${TITLE} - ${ARTIST}'\n\nexport const TRACK_FIELDS = {\n    INDEX: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${INDEX}', `${trackIndex + 1}`)\n    },\n    INDEX_PADDED: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const padding = playList.tracks.length.toString().length\n        return formatString.replace('${INDEX_PADDED}', (trackIndex + 1).toString().padStart(padding, '0'))\n    },\n    TITLE: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${TITLE}', playList.tracks?.[trackIndex]?.collectionEntry.title || 'Unknown Title')\n    },\n    ARTIST: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${ARTIST}', playList.tracks?.[trackIndex]?.collectionEntry.artist || 'Unknown Artist')\n    },\n    OFFSET: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const substitution = playList.tracks[trackIndex]?.timeOffsetString ?? ''\n        return formatString.replace('${OFFSET}', substitution)\n    }\n}\n\nexport function format(playList:Playlist, trackIndex:number, formatString:string): string {\n    Object.values(TRACK_FIELDS).forEach((trackKey) => { \n        formatString = trackKey(playList, trackIndex, formatString)\n    })\n    return formatString\n}\n\n\n/**\n * Converts a playlist to a human readable form.\n * \n * @param {Playlist} playlist  Playlist to turn into a human readable string.\n */\nexport function playlistToReadable(playlist:Playlist, FORMAT_STRING:string): string {\n    const result = []\n\n    result.push(playlist.name)\n\n    playlist.tracks\n        .map((track, index) => result.push(format(playlist, index, FORMAT_STRING)))\n\n    return result.join('\\n')\n}\n","import { TraktorParser } from './traktor'\nimport { RekordBoxParser } from './rekordbox'\nimport { M3U8Parser } from './m3u8'\nimport { CUEParser } from './cue'\nimport {RekordBoxTXTParser} from './rekordboxtxt'\nimport {DEFAULT_FORMAT_STRING, playlistToReadable, TRACK_FIELDS} from './formatter'\n\nconst PARSERS = [TraktorParser, RekordBoxParser, M3U8Parser, CUEParser, RekordBoxTXTParser]\n\nfunction getFormatString() {\n    let formatString = document.getElementById('formatString').value\n    if (formatString.length === 0) {\n        formatString = DEFAULT_FORMAT_STRING\n    }\n    return formatString\n}\n\n/**\n * Parses the uploaded file contents with the first matching parser, returning\n * the archive in canonical JSON format.\n * \n * @param {string} fileContents  Archive file contents.\n * @param {number} startTrackIndex Offset at which to start displaing tracks.\n * @param {boolean} onlyPlayedTracks (Traktor Only) Only return tracks that \n *                                   were played live.\n * @return Archive if parsed, otherwise null.\n */\n function parserArchive(fileContents, startTrackIndex, onlyPlayedTracks) {\n    const supportedParsers = PARSERS.map((parserClass) => {\n        const parser = new parserClass()\n        if (parser.supports(fileContents)) {\n            return parser\n        }\n    }).filter((v) => v)\n\n    if (!supportedParsers.length) {\n        return null\n    }\n\n    return supportedParsers[0].parse(fileContents, startTrackIndex, onlyPlayedTracks)\n}\n\nfunction convertToReadable() {\n    const fileContents = document.getElementById('archive').value\n    const archive = parserArchive(fileContents)\n\n    hideErrorResult()\n    hidePlaylistResults()\n\n    if (!archive) {\n        showErrorResult('Sorry, we could not parse that file.')\n        document.getElementById('trackList').innerText = \"No playlists found.\"\n        return\n    }\n    \n    // playlistsDropDown\n    const dropDown = document.getElementById('playlistsDropDown')\n    dropDown.replaceChildren('')\n    archive.playlists.forEach((playlist, index) => {\n        const option = document.createElement('option')\n        if (playlist.name.trim().length) {\n            option.innerText = playlist.name\n        } else {\n            option.innerText = `Playlist ${index + 1}`\n        }\n        option.playlist = playlist\n        dropDown.appendChild(option)\n    })\n    showPlaylistResults()\n    updateSelectedPlaylist()\n}\n\nfunction hidePlaylistResults() {\n    const div = document.getElementById('playlistResults')\n    div.setAttribute('class', 'hidden')\n}\n\nfunction showPlaylistResults() {\n    const div = document.getElementById('playlistResults')\n    div.setAttribute('class', '')\n}\n\nfunction hideErrorResult() {\n    const div = document.getElementById('errorResults')\n    div.setAttribute('class', 'hidden')\n}\nfunction showErrorResult(errorMessage) {\n    const div = document.getElementById('errorResults')\n    div.setAttribute('class', '')\n    const errorMessageElement = document.getElementById('errorMessage')\n    errorMessageElement.innerText = errorMessage\n}\n\nfunction updateSelectedPlaylist() {\n    const dropDown = document.getElementById('playlistsDropDown')\n    const selectedOption = dropDown.selectedOptions[0]\n    const startTrackIndex = Math.max(1, document.getElementById('startTrackIndex').value) - 1\n    const onlyPlayedTracks = document.getElementById('publicTracks').checked\n    const playlist = selectedOption.playlist\n    const filteredPlaylist = playlist.filter(startTrackIndex, onlyPlayedTracks)\n    document.getElementById('trackList').textContent = playlistToReadable(filteredPlaylist, getFormatString())\n}\nfunction uploadTracklist(e) {\n    const file = e.target.files[0]\n    if (!file) {\n        return\n    }\n    const reader = new FileReader()\n\n    reader.readAsText(file)\n    reader.onload = function () {\n        const archive = document.getElementById('archive')\n        archive.value = reader.result.toString()\n        convertToReadable()\n    }\n    // If you upload the same file twice the second upload won't trigger\n    // this function.  Clearing the value fixes this.\n    e.target.value = ''\n}\n\nfunction copyToClipboard() {\n    const copyText = document.getElementById('trackList').innerText\n    navigator.clipboard.writeText(copyText)\n}\n\nwindow.addEventListener('DOMContentLoaded', () => {\n    document.getElementById('archiveFile').addEventListener(\"change\", uploadTracklist, false)\n    document.getElementById('formatString').addEventListener(\"input\", updateSelectedPlaylist, false)\n    document.getElementById('startTrackIndex').addEventListener(\"input\", updateSelectedPlaylist, false)\n    document.getElementById('publicTracks').addEventListener(\"input\", updateSelectedPlaylist, false)\n    document.getElementById('copyToClipboard').addEventListener(\"click\", copyToClipboard, false)\n    document.getElementById('playlistsDropDown').addEventListener('change', updateSelectedPlaylist, false)\n    \n    const fieldList = Object.keys(TRACK_FIELDS)\n        .map((fieldName) => `\\${${fieldName}}`)\n        .join(' ')\n    document.getElementById('fieldList').textContent =\n        document.getElementById('fieldList').textContent + fieldList\n\n    const extensions = PARSERS.map((parser) => parser.extensions ).flat()\n    const uploadInput = document.getElementById('archiveFile')\n    uploadInput.accept = extensions.join(',')\n});\n","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\nexport class M3U8Parser implements Parser {\n    static format = \"RekordBox M3U8\"\n    static extensions = ['.m3u8']\n\n    supports(contents: string): boolean {\n        return contents.startsWith('#EXTM3U')\n    }\n    \n    parse(contents: string): Archive | null {\n        return parseM3U8(contents)\n    }  \n}\n\nfunction parseM3U8(\n    contents: string) {\n    if (!contents.startsWith('#EXTM3U')) {\n        return null\n    }\n    const archive: Archive = {\n        collection: {},\n        playlists: [] as Array<Playlist>,\n        format: 'M3U'\n    }\n    const playlist = new CPlaylist('Untitled Playlist')\n    archive.playlists.push(playlist)\n    \n    let currentArchiveTrack: ArchiveTrack | undefined\n    let currentTrack: PlaylistTrack | undefined\n\n    lineReader(contents, (line) => {\n        const regex = /^#EXTINF:(\\d+),(([^-]*$)|(.*)( - )(.*))/g\n        const match:RegExpExecArray|null = regex.exec(line)\n\n        if (match && match[1]) {\n            currentArchiveTrack = {\n                key: '__TEMP__',\n                title: match[6] || match[3] || '',\n                artist: match[4] || ''\n            }\n            currentTrack = {\n                key: currentArchiveTrack.key,\n                playedPublic: true,\n                collectionEntry: currentArchiveTrack\n            }\n        } else if (currentTrack && currentArchiveTrack) {\n            const key:string = line\n\n            // The line after the EXTINF has the file path which we use as our\n            // unique key as the integer after EXTINF is not sufficient.\n            currentArchiveTrack.key = key\n            currentTrack.key = key\n\n            archive.collection[key] = currentArchiveTrack\n            playlist.tracks.push(currentTrack)\n        }\n    })\n    return archive\n}\n"],"names":["$5285648c815df37f$export$807e79111d5cf0eb","constructor","name","tracks","this","filter","startIndex","playedLive","result","_","index","track","playedPublic","$6194f6c5cc7a6359$var$nmlCollection","xmlDoc","Array","prototype","map","call","querySelectorAll","entry","title","attributes","value","artist","location","key","reduce","collection","$6194f6c5cc7a6359$var$CTraktorPlaylist","super","playList","startTimeJS","start","lastTime","length","hasHours","$6194f6c5cc7a6359$var$NMLTimeToTime","hours","hasHoursTest","Math","floor","console","assert","forEach","timeOffset","timeOffsetString","t","stripHours","HH","$6194f6c5cc7a6359$var$hours","toString","padStart","MM","$6194f6c5cc7a6359$var$minutes","SS","$6194f6c5cc7a6359$var$seconds","$6194f6c5cc7a6359$var$timeString","$6194f6c5cc7a6359$var$computeTrackOffsets","$6194f6c5cc7a6359$var$year","x","$6194f6c5cc7a6359$var$month","$6194f6c5cc7a6359$var$day","nmlTime","minutes","seconds","$edd58d98252a5397$var$parseCollection","getElementsByTagName","$b7a1dabe93a79a87$export$5087fc42c9e3571c","contents","cb","split","line","trim","$f28ffb3b002ef57c$export$cc7e12c76513e857","data","match","exec","toUpperCase","stringParam","param","$f28ffb3b002ef57c$var$HeaderState","onCommand","context","command","performer","onNextState","$f28ffb3b002ef57c$var$PlaylistState","nameFields","header","field","playlist","join","archive","playlists","push","$f28ffb3b002ef57c$var$TrackState","id","random","collectionTrack","playlistTrack","collectionEntry","$33b811a556bc1d79$var$TXT_MAP","$33b811a556bc1d79$var$getField","headers","fields","fieldIndex","undefined","$f6cce17ab644ef19$export$54dbb75bbd456ec6","INDEX","trackIndex","formatString","replace","INDEX_PADDED","padding","TITLE","ARTIST","OFFSET","substitution","$f6cce17ab644ef19$export$eac847f019cd2b46","FORMAT_STRING","Object","values","trackKey","$35da740d59af89ba$var$PARSERS","static","parseXML","DOMParser","parseFromString","supports","parse","format","playlistNodes","playlistNode","extendedData","parseInt","startTime","startDate","year","nmlDate","month","day","Date","$6194f6c5cc7a6359$var$nmlPlaylists","$6194f6c5cc7a6359$var$parseTraktor","$edd58d98252a5397$var$parsePlaylists","$edd58d98252a5397$var$parseRekordBox","startsWith","currentArchiveTrack","currentTrack","$1a06f555bd40ddc8$var$parseM3U8","state","commandString","$f28ffb3b002ef57c$export$c32dec9fe4d709a2","$f28ffb3b002ef57c$export$afaa313fa0c73604","cur","$33b811a556bc1d79$var$textReader","archiveTrack","$35da740d59af89ba$var$convertToReadable","fileContents","startTrackIndex","onlyPlayedTracks","supportedParsers","parserClass","parser","v","$35da740d59af89ba$var$parserArchive","document","getElementById","setAttribute","errorMessage","innerText","$35da740d59af89ba$var$showErrorResult","dropDown","replaceChildren","option","createElement","appendChild","$35da740d59af89ba$var$updateSelectedPlaylist","selectedOption","selectedOptions","max","checked","filteredPlaylist","textContent","$35da740d59af89ba$var$getFormatString","$35da740d59af89ba$var$uploadTracklist","e","file","target","files","reader","FileReader","readAsText","onload","$35da740d59af89ba$var$copyToClipboard","copyText","navigator","clipboard","writeText","window","addEventListener","fieldList","keys","fieldName","extensions","flat","accept"],"version":3,"file":"index.30ddafb0.js.map"}