{"mappings":"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","sources":["src/parsers/archive.ts","src/parsers/common.ts","src/parsers/traktor.ts","src/parsers/rekordbox.ts","src/parsers/cue.ts","src/parsers/rekordboxtxt.ts","src/formatter.ts","src/index.ts","src/parsers/m3u8.ts"],"sourcesContent":["export interface ArchiveTrack {\n    key: string\n    title: string\n    artist: string\n}\nexport interface PlayedTime {\n    hours: number\n    minutes: number\n    seconds: number\n}\nexport interface PlayedDate {\n    year: number\n    month: number\n    day: number\n}\nexport interface PlaylistTrack {\n    key: string\n    collectionEntry: ArchiveTrack\n    playedPublic: boolean\n    startTime?: PlayedTime\n    startDate?: PlayedDate\n    startTimeJS?: Date\n    timeOffset?: number\n    timeOffsetString?: string\n}\nexport interface Playlist {\n    name: string\n    tracks: Array<PlaylistTrack>\n\n    filter(startIndex: number, playedLive: boolean): Playlist\n}\n\nexport type Collection = { [n: string]: ArchiveTrack }\n\nexport interface Archive {\n    collection: Collection\n    playlists: Array<Playlist>\n    format: string\n}\n\nexport interface Parser {   \n    supports(): boolean\n    parse() : Archive | null\n}\n\nexport class CPlaylist implements Playlist {\n    name:string \n    tracks: Array<PlaylistTrack>\n\n    constructor(name:string = '', tracks: Array<PlaylistTrack> = []) {\n        this.name = name\n        this.tracks = tracks\n    }\n\n    filter(startIndex: number, playedLive: boolean): Playlist {\n        let result = new CPlaylist()\n        result.name = this.name\n        result.tracks = this.tracks\n            .filter((_, index) => index >= (startIndex))\n            .filter((track) => playedLive ? track.playedPublic : true)\n\n        return result\n    }\n}\n","export function lineReader(contents:string, cb: (line:string, index:number) => void): void {\n    const lines = contents.split('\\n')\n    lines.forEach((line, index) => {\n        line = line.trim()\n        if (line.length) {\n            cb(line, index)\n        }\n    })\n}\n\n/**\n * JSDom.querySelectorAll no work with 'TAG > TAG' selectors so we got this.\n */\n export function querySelectorAllParents(xmlDoc: Element | XMLDocument | undefined, parents:string[]) {\n    while (xmlDoc && parents[0]) {\n        const tagName = parents.shift() as string\n        const isLastTag = parents.length === 0\n        const children = xmlDoc.querySelectorAll(tagName)\n\n        if (isLastTag) {\n            return children\n        }\n        xmlDoc = children[0]\n    }\n\n    return undefined\n}\n\n","import { Archive, ArchiveTrack, Collection, Playlist, CPlaylist, Parser, PlaylistTrack } from \"./archive\"\nimport { querySelectorAllParents } from \"./common\"\n\nexport class TraktorParser implements Parser {\n    static format = \"Traktor\"\n    static extensions = ['.nml']\n    xmlDoc: XMLDocument | null\n\n    constructor(contents:string) {\n        this.xmlDoc = TraktorParser.parseXML(contents)\n        if (this.xmlDoc) {\n            const root = this.xmlDoc.getElementsByTagName(\"NML\")\n            if (root.length === 0) {\n                this.xmlDoc = null\n            }\n        }\n    }\n\n    private static parseXML(contents:string) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports(): boolean {\n        return this.xmlDoc !== null\n    }\n    \n    parse(): Archive | null {\n        if (!this.xmlDoc) {\n            return null\n        }\n\n        return parseTraktor(this.xmlDoc)\n    }  \n}\n\nfunction parseTraktor(xmlDoc:XMLDocument) {\n    const archive: Archive = {\n        collection: nmlCollection(xmlDoc),\n        playlists: [],\n        format: 'Traktor NML'\n    }\n    archive.playlists = nmlPlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\n/**\n * Generates the Collection from an NML file.  Only thing to note is that we \n * are required to generate the track key from LOCATION node's attributes.\n * This is odd because PLAYLIST ENTRY node's PRIMARYKEY already has this \n * pre-computed.  Unsure why Traktor doesn't do this for COLLECTION ENTRY.\n */\nfunction nmlCollection(xmlDoc: XMLDocument): Collection {\n    // Selector we are emulating 'NML > COLLECTION > ENTRY'\n    const collectionEntries = querySelectorAllParents(xmlDoc, ['NML', 'COLLECTION', 'ENTRY']) ?? []\n\n    return Array.prototype.map.call(collectionEntries,\n        (entry: Element, index: number) => {\n            const location = entry.getElementsByTagName('LOCATION')[0] as Element\n            const key = \n                `${location.attributes.getNamedItem('VOLUME')?.value}` +\n                `${location.attributes.getNamedItem('DIR')?.value}` +\n                `${location.attributes.getNamedItem('FILE')?.value}`\n            return { \n                title: entry.attributes.getNamedItem('TITLE')?.value, \n                artist: entry.attributes.getNamedItem('ARTIST')?.value,\n                key\n            }\n        })\n        .reduce((collection: Collection, track:ArchiveTrack) => {\n            collection[track.key] = track; \n            return collection\n        }, {})\n}\n\nfunction nmlPlaylists(xmlDoc: XMLDocument, collection:Collection): Playlist[] {\n    // Selector we are emulating \"NML > PLAYLISTS NODE[TYPE='PLAYLIST']\"\n    const playlistNodes = querySelectorAllParents(xmlDoc, ['NML', 'PLAYLISTS', \"NODE[TYPE='PLAYLIST']\"]) ?? []\n\n    return Array.prototype.map.call(playlistNodes, (playlistNode: Element) => {\n        const playList = new CTraktorPlaylist(\n            playlistNode.attributes.getNamedItem('NAME')?.value,\n            []\n        )\n        const playListTrackNodes = querySelectorAllParents(playlistNode, ['PLAYLIST', 'ENTRY']) ?? []\n        playList.tracks = Array.prototype.map.call(playListTrackNodes,\n            (entry: Element, index: number) => {\n                const keyElement = entry.getElementsByTagName('PRIMARYKEY')[0]\n                const key = keyElement?.attributes.getNamedItem('KEY')?.value ?? ''\n                const track: PlaylistTrack = {\n                    key,\n                    collectionEntry: collection[key] as ArchiveTrack,\n                    playedPublic: true\n                }\n\n                const extendedData = entry.getElementsByTagName('EXTENDEDDATA')[0]\n                if (extendedData) {\n                    track.playedPublic = !!parseInt(extendedData.attributes.getNamedItem('PLAYEDPUBLIC')?.value ?? '1')\n                    const startTime = parseInt(extendedData.attributes.getNamedItem('STARTTIME')?.value ?? '0')\n                    track.startTime = NMLTimeToTime(startTime)\n                    const startDate = parseInt(extendedData.attributes.getNamedItem('STARTDATE')?.value ?? '0')\n                    track.startDate = NMLDateToDate(startDate)\n                    track.startTimeJS = new Date(\n                        track.startDate.year,\n                        track.startDate.month,\n                        track.startDate.day,\n                        track.startTime.hours,\n                        track.startTime.minutes,\n                        track.startTime.seconds\n                    )\n                } \n                return track\n            })\n        \n        return playList\n    })\n}\n\nclass CTraktorPlaylist extends CPlaylist {\n    filter(startIndex: number, playedLive: boolean) {\n        const result = super.filter(startIndex, playedLive)\n        computeTrackOffsets(result)\n        return result\n    }\n}\n\n/**\n * If extendeddata attributes are present in the playlist, computes the offset\n * that the track started at in [HH:]MM:SS format.\n * \n * @param {PlayList} playList \n */\nfunction computeTrackOffsets(playList: Playlist) {\n    const firstTrack = playList.tracks[0]\n    const lastTrack = playList.tracks[playList.tracks.length - 1]\n\n    if (firstTrack && lastTrack && firstTrack?.startTimeJS && lastTrack?.startTimeJS) {\n        const start = firstTrack.startTimeJS.getTime()\n        \n        playList.tracks.forEach((track: PlaylistTrack) => {\n            if (track.startTimeJS) {\n                track.timeOffset = (track.startTimeJS.getTime() - start) / 1000\n                track.timeOffsetString = timeString(track.timeOffset)\n            }\n        })\n    }\n}\n\ntype NMLDateValue = number\n\ntype NMLDate = {\n    year: number\n    month: number\n    day: number\n}\n\n// Functions to parse EXTENDEDDATA STARTDATE \nfunction year (x: NMLDateValue): number { return x >> 16 }\nfunction month(x: NMLDateValue): number { return (x >> 8) % 256 }\nfunction day  (x: NMLDateValue): number { return x % 256 }\n\nfunction NMLDateToDate(nmlDate: NMLDateValue): NMLDate {\n    return {\n        year: year(nmlDate),\n        month: month(nmlDate),\n        day: day(nmlDate)\n    }\n}\n// function DateToNMLDate(date: NMLDate): NMLDateValue {\n//     return date.year * 2**16 + date.month * 2**8 + date.day\n// }\n\n// Functions to parse EXTENDEDDATA STARTTIME \ntype NMLTimeValue = number\n\ntype NMLTime = {\n    hours: number\n    minutes: number\n    seconds: number\n}\n\nfunction seconds(t: NMLTimeValue): number { return t % 60 }\nfunction minutes(t: NMLTimeValue): number { return Math.floor((t - 3600*Math.floor(t/3600))/60) }\nfunction hours(t: NMLTimeValue): number { return Math.floor(t/3600) }\n\nfunction timeString(t: NMLTimeValue): string {\n    const HH = hours(t).toString().padStart(2, '0')\n    const MM = minutes(t).toString().padStart(2, '0')\n    const SS = seconds(t).toString().padStart(2, '0')\n    if (hours(t) === 0) {\n        return `${MM}:${SS}`\n    } else {\n        return `${HH}:${MM}:${SS}`\n    }\n}\n\nfunction NMLTimeToTime(nmlTime: NMLTimeValue): NMLTime {\n    return {\n        hours: hours(nmlTime),\n        minutes: minutes(nmlTime),\n        seconds: seconds(nmlTime)\n    }\n}\n","import { Archive, ArchiveTrack, Collection, CPlaylist, Parser, PlaylistTrack } from \"./archive\"\nimport { querySelectorAllParents } from \"./common\"\n\nexport class RekordBoxParser implements Parser {\n    static format = \"RekordBox\"\n    static extensions = ['.xml']\n    xmlDoc: XMLDocument | null\n\n    constructor(contents:string) {\n        this.xmlDoc = RekordBoxParser.parseXML(contents)\n        if (this.xmlDoc) {\n            const root = this.xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n            if (root.length === 0) {\n                this.xmlDoc = null\n            }\n        }\n    }\n\n    private static parseXML(contents: string) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(contents, \"text/xml\")\n        const parseError = xmlDoc.getElementsByTagName(\"parsererror\")\n\n        if (parseError.length !== 0) {\n            return null\n        }\n        return xmlDoc\n    }\n\n    supports():boolean {\n        return this.xmlDoc !== null\n    }\n    \n    parse():Archive|null {\n        if (!this.xmlDoc) {\n            return null\n        }\n\n        return parseRekordBox(this.xmlDoc)\n    }  \n}\n\nfunction parseRekordBox(xmlDoc:XMLDocument) {\n    const rekordBoxRoot = xmlDoc.getElementsByTagName(\"DJ_PLAYLISTS\")\n    if (!rekordBoxRoot.length) {\n        return null\n    }\n\n    const archive = {\n        collection: parseCollection(xmlDoc),\n        playlists: [],\n        format: 'RekordBox'\n    }\n    archive.playlists = parsePlaylists(xmlDoc, archive.collection)\n    return archive\n}\n\nfunction parseCollection(xmlDoc:XMLDocument) {\n    // Selector we are simulating 'DJ_PLAYLISTS > COLLECTION > TRACK'\n    const tracks = querySelectorAllParents(xmlDoc, ['DJ_PLAYLISTS', 'COLLECTION', 'TRACK'])\n    \n    const collection = Array.prototype.map.call(tracks,\n        (entry:Element, index:number) => {\n            return { \n                key: entry.attributes.getNamedItem('TrackID')?.value, \n                title: entry.attributes.getNamedItem('Name')?.value, \n                artist: entry.attributes.getNamedItem('Artist')?.value\n            }\n        })\n        .reduce((collection:Collection, track:ArchiveTrack) => {\n            collection[track.key] = track; return collection\n        }, {})\n    \n        return collection\n}\n\nfunction parsePlaylists(xmlDoc: XMLDocument, collection: Collection) {\n    const playlistNodes = xmlDoc.querySelectorAll(\"NODE[Type='1']\")\n\n    return Array.prototype.map.call(playlistNodes, (playlistNode:Element) => {\n        const name = playlistNode.attributes.getNamedItem('Name')?.value || ''\n        const playList = new CPlaylist(name, [])\n\n        playList.tracks = Array.prototype.map.call(playlistNode.getElementsByTagName('TRACK'),\n            (entry: Element, index: number) => {\n                const key = entry.attributes.getNamedItem('Key')?.value ?? ''\n                const track:PlaylistTrack = {\n                    key: key,\n                    playedPublic: true,\n                    collectionEntry: collection[key] as ArchiveTrack\n                }\n                return track\n            })\n        \n        return playList\n    })\n}","import {Parser, Archive, Playlist, PlaylistTrack, ArchiveTrack, CPlaylist} from './archive'\nimport {lineReader} from './common'\n\n// https://wiki.hydrogenaud.io/index.php?title=Cue_sheet\nexport class CUEParser implements Parser {\n    static format = \"RekordBox CUE\"\n    static extensions = ['.cue']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n\n    supports(): boolean {\n        // Not the best, file doesn't actually have to havce this but RekordBox\n        // does output the REM DATE.\n        return this.contents.startsWith('REM DATE ')\n    }\n    \n    parse(): Archive | null {\n        return cueParser(this.contents)\n    }\n}\n\nexport class Command {\n    data:string \n    \n    constructor(data:string) {\n        this.data = data\n    }\n\n    get name():string {\n        const match = /(\\w+)(\\s|$)/g.exec(this.data)\n        if (match?.[1]) {\n            return match[1].toUpperCase()\n        }\n        return ''\n    }\n\n    stringParam() :string|undefined {\n        // Quoted Strings\n        const QUOTED = /^\\s*(\\w+)\\s\"(.*)\"/\n        let match = QUOTED.exec(this.data)\n        if (match?.[2]) {\n            return match[2]\n        }\n        // Embedded Quotes\n        match = /^\\s*\\w+\\s(.*)$/.exec(this.data)\n        if (match?.[1]) {\n            return match[1]\n        }\n        return undefined\n    }\n    param(index:number): string|undefined {\n        const lines = this.data.split(' ')\n        return lines[index]\n    }\n}\n\ntype Context = {\n    archive: Archive,\n    header: HeaderState\n}\n\ninterface State {\n    onCommand(context: Context, command:Command): void\n    onNextState(context: Context, command:Command): State\n}\n\nclass HeaderState implements State {\n    title: string|undefined\n    performer: string|undefined\n\n    onCommand(context: Context, command: Command): void {\n        switch (command.name) {\n            case 'TITLE':\n                this.title = command.stringParam()\n                break\n            case 'PERFORMER':\n                this.performer = command.stringParam()\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'FILE') {\n            return new PlaylistState()\n        }\n        return this\n    }\n}\n\nclass PlaylistState implements State {\n    onCommand(context: Context, command: Command): void {\n        const nameFields = [context.header.title, context.header.performer]\n            .filter((field) => field)\n        const playlist: Playlist = new CPlaylist(nameFields.join(' - '))\n\n        context.archive.playlists.push(playlist)\n    } \n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nclass TrackState implements State {\n    id: string\n\n    constructor(context:Context, id:string|undefined) {\n        this.id = id  ?? '' + Math.random()\n        const collectionTrack:ArchiveTrack = {\n            key: this.id,\n            title: '',\n            artist: ''\n        }\n        const playlist = context.archive.playlists[context.archive.playlists.length - 1]\n        const playlistTrack: PlaylistTrack = {\n            key: collectionTrack.key,\n            collectionEntry: collectionTrack,\n            playedPublic: true\n        }\n        playlist?.tracks.push(playlistTrack)\n    context.archive.collection[collectionTrack.key] = collectionTrack\n    }\n\n    playlist(context: Context, ): Playlist {\n        return context.archive.playlists[context.archive.playlists.length - 1] as Playlist\n    }\n\n    playlistTrack(context: Context, ): PlaylistTrack {\n        const playlist: Playlist = this.playlist(context)\n        return playlist.tracks[playlist.tracks.length - 1] as PlaylistTrack\n    }\n\n    collectionTrack(context: Context, ): ArchiveTrack {\n        const playlistTrack = this.playlistTrack(context)\n        return context.archive.collection[playlistTrack.key] as ArchiveTrack\n    }\n\n    onCommand(context: Context, command: Command): void {\n        const collectionTrack = this.collectionTrack(context)\n\n        switch (command.name) {\n            case 'TITLE':\n                collectionTrack.title = command.stringParam() ?? ''\n                break\n            case 'PERFORMER':\n                collectionTrack.artist = command.stringParam() ?? ''\n                break\n        }\n    }\n    onNextState(context: Context, command: Command): State {\n        if (command.name === 'TRACK') {\n            return new TrackState(context, command.param(1))\n        }\n        return this\n    }\n}\n\nexport function cueReader(contents:string, cb:(command:Command) => void) {\n    lineReader(contents, (commandString:string, index:number) => {\n        const command:Command = new Command(commandString)\n        cb(command)\n    })\n}\n\nexport function cueParser(contents:string):Archive {\n    let state:State = new HeaderState()\n    const context:Context = {\n        archive:{\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive,\n        header: state as HeaderState\n    }\n\n    cueReader(contents, (command:Command) => {\n        state.onCommand(context, command)\n        state = state = state.onNextState(context, command)\n    })\n\n    return context.archive\n}","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\ntype Headers = {[n: string]: number}\n\nexport class RekordBoxTXTParser implements Parser {\n    static format = \"RekordBox TXT\"\n    static extensions = ['.txt']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n    supports(): boolean {\n        return this.contents.trim().startsWith('#\\t')\n    }\n    \n    parse(): Archive | null {\n        const archive = {\n            collection: {},\n            playlists: [],\n            format: 'CUE'\n        } as Archive\n        const playlist: Playlist = new CPlaylist()\n\n        textReader(this.contents, (archiveTrack:ArchiveTrack) => {\n            const playlistTrack: PlaylistTrack = {\n                key: archiveTrack.key,\n                collectionEntry: archiveTrack,\n                playedPublic: true\n            }\n            archive.collection[archiveTrack.key] = archiveTrack\n            if (!playlist.tracks.length) {\n                archive.playlists.push(playlist)\n            }\n            playlist.tracks.push(playlistTrack)\n        })\n\n        return archive\n    }\n}\n\nconst TXT_MAP = {\n    TITLE: 'TRACK TITLE',\n    ARTIST: 'ARTIST',\n    KEY: '#'\n}\n\nfunction getField(name:string, headers:Headers, fields: Array<string>): string|null {\n    const fieldIndex = headers[name]\n\n    if (fieldIndex !== undefined && fields[fieldIndex]) {\n        return fields[fieldIndex] as string\n    }\n    return null\n}\n\nfunction textReader(contents:string, cb:(track:ArchiveTrack) => void) {\n    let headers: Headers = {}\n\n    lineReader(contents, (line:string, index:number) => {\n        const fields = line.split('\\t')\n\n        if (index === 0) {\n            headers = fields.reduce((headers:Headers, cur:string, index:number) => {\n                headers[cur.toUpperCase()] = index\n                return headers\n            }, headers)\n        } else {\n            cb({\n                key: getField(TXT_MAP.KEY, headers, fields) ?? `${Math.random()}`,\n                title: getField(TXT_MAP.TITLE, headers, fields) ?? '',\n                artist: getField(TXT_MAP.ARTIST, headers, fields) ?? ''\n            })\n        }\n    })\n}","import { Playlist } from \"./parsers/archive\"\n\nexport const DEFAULT_FORMAT_STRING = '${INDEX}. ${TITLE} - ${ARTIST}'\n\nexport const TRACK_FIELDS = {\n    INDEX: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${INDEX}', `${trackIndex + 1}`)\n    },\n    INDEX_PADDED: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const padding = playList.tracks.length.toString().length\n        return formatString.replace('${INDEX_PADDED}', (trackIndex + 1).toString().padStart(padding, '0'))\n    },\n    TITLE: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${TITLE}', playList.tracks?.[trackIndex]?.collectionEntry.title || 'Unknown Title')\n    },\n    ARTIST: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        return formatString.replace('${ARTIST}', playList.tracks?.[trackIndex]?.collectionEntry.artist || 'Unknown Artist')\n    },\n    OFFSET: (playList:Playlist, trackIndex:number, formatString:string): string => {\n        const substitution = playList.tracks[trackIndex]?.timeOffsetString ?? ''\n        return formatString.replace('${OFFSET}', substitution)\n    }\n}\n\nexport function format(playList:Playlist, trackIndex:number, formatString:string): string {\n    Object.values(TRACK_FIELDS).forEach((trackKey) => { \n        formatString = trackKey(playList, trackIndex, formatString)\n    })\n    return formatString\n}\n\nexport function buildTags(playlist: Playlist): string[] {\n    const tags = playlist.tracks\n      .map((track) => track.collectionEntry.artist)\n      .map((artist) => artist.split(','))\n      .flat()\n      .map((artist) => artist.replace(/\\(.*$/g, ''))\n      .map((artist) => artist.split('&'))\n      .flat()\n      .map((artist) => artist.trim().replace(/\\s+/g, ''))\n      .map((artist) => `#${artist.toLocaleLowerCase()}`)\n\n    return [...new Set(tags)]\n  }\n\n/**\n * Converts a playlist to a human readable form.\n * \n * @param {Playlist} playlist  Playlist to turn into a human readable string.\n */\nexport function playlistToReadable(playlist:Playlist, FORMAT_STRING:string): string {\n    const result = []\n\n    result.push('Artist Tags')\n    result.push(buildTags(playlist).join(' '))\n    result.push('')\n\n    result.push(playlist.name)\n\n    playlist.tracks\n        .map((track, index) => result.push(format(playlist, index, FORMAT_STRING)))\n\n    return result.join('\\n')\n}\n","import { TraktorParser } from './parsers/traktor'\nimport { RekordBoxParser } from './parsers/rekordbox'\nimport { M3U8Parser } from './parsers/m3u8'\nimport { CUEParser } from './parsers/cue'\nimport {RekordBoxTXTParser} from './parsers/rekordboxtxt'\nimport {DEFAULT_FORMAT_STRING, playlistToReadable, TRACK_FIELDS} from './formatter'\nimport { Playlist } from './parsers/archive'\n\n/**\n * HACK - TypeScript errors out on every possible null value from\n * getElementbyId so we use this to ignore it and let the app crash at runtime.\n */\n function getElementById<T = HTMLElement>(id: string): T {\n    return document.getElementById(id) as T\n}\n\nconst PARSERS = [TraktorParser, RekordBoxParser, M3U8Parser, CUEParser, RekordBoxTXTParser]\n\nfunction getFormatString() {\n    const formatStringInput = getElementById<HTMLInputElement>('formatString')\n    let formatString = formatStringInput.value\n    if (formatString.length === 0) {\n        formatString = DEFAULT_FORMAT_STRING\n    }\n    return formatString\n}\n\n/**\n * Parses the uploaded file contents with the first matching parser, returning\n * the archive in canonical JSON format.\n * \n * @param {string} fileContents  Archive file contents.\n * @return Archive if parsed, otherwise null.\n */\n function parseArchive(fileContents: string) {\n    for (let parserClass of PARSERS) {\n        const parser = new parserClass(fileContents)\n        if (parser.supports()) {\n            return parser.parse()\n        }\n    }\n\n    return null\n}\n\nfunction convertToReadable(fileContents: string) {\n    hideErrorResult()\n    hidePlaylistResults()\n\n    const archive = parseArchive(fileContents)\n\n    if (!archive) {\n        showErrorResult('Sorry, we could not parse that file.')\n        const trackListElements = getElementById('trackList')\n        trackListElements.innerText = \"No playlists found.\"\n        return\n    }\n    \n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    dropDown.replaceChildren('')\n    archive.playlists.forEach((playlist, index) => {\n        const option = document.createElement('option')\n        if (playlist.name.trim().length) {\n            option.innerText = playlist.name\n        } else {\n            option.innerText = `Playlist ${index + 1}`\n        }\n        (option as any).playlist = playlist\n        dropDown.appendChild(option)\n    })\n    \n    showPlaylistResults()\n    updateSelectedPlaylist()\n}\n\nfunction hidePlaylistResults() {\n    const div = getElementById('playlistResults')\n    div.setAttribute('class', 'hidden')\n}\n\nfunction showPlaylistResults() {\n    const div = getElementById('playlistResults')\n    div.setAttribute('class', '')\n}\n\nfunction hideErrorResult() {\n    const div = getElementById('errorResults')\n    div.setAttribute('class', 'hidden')\n}\nfunction showErrorResult(errorMessage: string) {\n    const div = getElementById('errorResults')\n    div.setAttribute('class', '')\n    const errorMessageElement = getElementById('errorMessage')\n    errorMessageElement.innerText = errorMessage\n}\n\nfunction updateSelectedPlaylist() {\n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    const selectedOption = dropDown.selectedOptions[0]\n    let startTrackIndex: number = parseInt(getElementById<HTMLInputElement>('startTrackIndex').value) || 1\n    startTrackIndex = Math.max(0, startTrackIndex - 1)\n    const onlyPlayedTracks = getElementById<HTMLInputElement>('publicTracks')\n    const playlist: Playlist = (selectedOption as any).playlist as Playlist\n    const filteredPlaylist = playlist.filter(startTrackIndex, onlyPlayedTracks.checked)\n    getElementById('trackList').textContent = playlistToReadable(filteredPlaylist, getFormatString())\n}\n\nfunction uploadTracklist(e: Event) {XMLHttpRequestEventTarget\n    const fileElement = e.target as HTMLInputElement\n    const file = fileElement?.files?.[0]\n    if (!file) {\n        return\n    }\n    const reader = new FileReader()\n\n    reader.readAsText(file)\n    reader.onload = function () {\n        const newArchiveText: string = reader?.result?.toString() ?? ''\n        convertToReadable(newArchiveText)\n    }\n    // If you upload the same file twice the second upload won't trigger\n    // this function.  Clearing the value fixes this.\n    fileElement.value = ''\n}\n\nfunction copyToClipboard() {\n    const trackListElement = getElementById('trackList')\n    const copyText = trackListElement.innerText\n    navigator.clipboard.writeText(copyText)\n}\n\nfunction saveToTxtFile() {\n    const trackListElement = getElementById('trackList')\n    const copyText = trackListElement.innerText\n    const blob = new Blob([copyText], {type: \"text/plain;charset=utf-8\"});\n    let playlistName = '' as string\n    const dropDown = getElementById<HTMLSelectElement>('playlistsDropDown')\n    const selectedOption = dropDown.selectedOptions[0]\n    if (selectedOption) {\n        playlistName = selectedOption.innerText + '.txt'\n    } else {\n        playlistName = 'playlist.txt'\n    }\n    saveAs(blob, playlistName);\n}\n\nfunction saveAs(blob: Blob, fileName: string) {\n    const link = document.createElement(\"a\");\n    link.download = fileName\n    link.href = URL.createObjectURL(blob);\n    link.click();\n}\n\nwindow.addEventListener('DOMContentLoaded', () => {\n    getElementById('archiveFile').addEventListener(\"change\", uploadTracklist, false)\n    getElementById('formatString').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('startTrackIndex').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('publicTracks').addEventListener(\"input\", updateSelectedPlaylist, false)\n    getElementById('copyToClipboard').addEventListener(\"click\", copyToClipboard, false)\n    getElementById('saveToTxtFile').addEventListener(\"click\", saveToTxtFile, false)\n    getElementById('playlistsDropDown').addEventListener('change', updateSelectedPlaylist, false)\n    \n    const fieldList = Object.keys(TRACK_FIELDS)\n        .map((fieldName) => `\\${${fieldName}}`)\n        .join(' ')\n    const fieldListElement = getElementById('fieldList') \n        fieldListElement.textContent =\n        fieldListElement.textContent + fieldList\n\n    const extensions = PARSERS.map((parser) => parser.extensions ).flat()\n    const uploadInput = getElementById<HTMLInputElement>('archiveFile')\n    uploadInput.accept = extensions.join(',')\n});\n\n\n","import { Archive, ArchiveTrack, CPlaylist, Parser, Playlist, PlaylistTrack } from \"./archive\"\nimport { lineReader } from \"./common\"\n\nexport class M3U8Parser implements Parser {\n    static format = \"RekordBox M3U8\"\n    static extensions = ['.m3u8']\n    private contents: string\n\n    constructor(contents:string) {\n        this.contents = contents\n    }\n\n    supports(): boolean {\n        return this.contents.startsWith('#EXTM3U')\n    }\n    \n    parse(): Archive | null {\n        return parseM3U8(this.contents)\n    }  \n}\n\nfunction parseM3U8(\n    contents: string) {\n    if (!contents.startsWith('#EXTM3U')) {\n        return null\n    }\n    const archive: Archive = {\n        collection: {},\n        playlists: [] as Array<Playlist>,\n        format: 'M3U'\n    }\n    const playlist = new CPlaylist('Untitled Playlist')\n    archive.playlists.push(playlist)\n    \n    let currentArchiveTrack: ArchiveTrack | undefined\n    let currentTrack: PlaylistTrack | undefined\n\n    lineReader(contents, (line) => {\n        const regex = /^#EXTINF:(\\d+),(([^-]*$)|(.*)( - )(.*))/g\n        const match:RegExpExecArray|null = regex.exec(line)\n\n        if (match && match[1]) {\n            currentArchiveTrack = {\n                key: '__TEMP__',\n                title: match[6] || match[3] || '',\n                artist: match[4] || ''\n            }\n            currentTrack = {\n                key: currentArchiveTrack.key,\n                playedPublic: true,\n                collectionEntry: currentArchiveTrack\n            }\n        } else if (currentTrack && currentArchiveTrack) {\n            const key:string = line\n\n            // The line after the EXTINF has the file path which we use as our\n            // unique key as the integer after EXTINF is not sufficient.\n            currentArchiveTrack.key = key\n            currentTrack.key = key\n\n            archive.collection[key] = currentArchiveTrack\n            playlist.tracks.push(currentTrack)\n        }\n    })\n    return archive\n}\n"],"names":["$657abdbdcf4245f0$export$807e79111d5cf0eb","constructor","name","tracks","this","filter","startIndex","playedLive","result","_","index","track","playedPublic","$34fb56a4ecb7eab0$export$5087fc42c9e3571c","contents","cb","split","forEach","line","trim","length","$34fb56a4ecb7eab0$export$4303e24c56c34701","xmlDoc","parents","tagName","shift","isLastTag","children","querySelectorAll","$7bcb0e88a8caa2ba$export$2027af7c5cd3a36c","static","parseXML","getElementsByTagName","DOMParser","parseFromString","supports","parse","archive","collection","$7bcb0e88a8caa2ba$var$nmlCollection","playlists","format","playlistNodes","Array","prototype","map","call","playlistNode","playList","$7bcb0e88a8caa2ba$var$CTraktorPlaylist","attributes","getNamedItem","value","playListTrackNodes","entry","key","collectionEntry","extendedData","parseInt","startTime","hours","$7bcb0e88a8caa2ba$var$hours","nmlTime","minutes","$7bcb0e88a8caa2ba$var$minutes","seconds","$7bcb0e88a8caa2ba$var$seconds","startDate","year","$7bcb0e88a8caa2ba$var$year","nmlDate","month","$7bcb0e88a8caa2ba$var$month","day","$7bcb0e88a8caa2ba$var$day","startTimeJS","Date","$7bcb0e88a8caa2ba$var$nmlPlaylists","$7bcb0e88a8caa2ba$var$parseTraktor","collectionEntries","location","title","artist","reduce","super","firstTrack","lastTrack","start","getTime","timeOffset","timeOffsetString","t","HH","toString","padStart","MM","SS","$7bcb0e88a8caa2ba$var$timeString","$7bcb0e88a8caa2ba$var$computeTrackOffsets","x","Math","floor","$cf173d13f3653799$export$5bbeb5f972cff134","$cf173d13f3653799$var$parseCollection","$cf173d13f3653799$var$parsePlaylists","$cf173d13f3653799$var$parseRekordBox","$d5b03de8161447d4$export$cc7e12c76513e857","data","match","exec","toUpperCase","stringParam","param","$d5b03de8161447d4$var$HeaderState","onCommand","context","command","performer","onNextState","$d5b03de8161447d4$var$PlaylistState","nameFields","header","field","playlist","join","push","$d5b03de8161447d4$var$TrackState","id","random","collectionTrack","playlistTrack","$1aa7d39bd7258560$var$TXT_MAP","$1aa7d39bd7258560$var$getField","headers","fields","fieldIndex","undefined","$f6cce17ab644ef19$export$54dbb75bbd456ec6","INDEX","trackIndex","formatString","replace","INDEX_PADDED","padding","TITLE","ARTIST","OFFSET","substitution","$f6cce17ab644ef19$export$eac847f019cd2b46","FORMAT_STRING","tags","flat","toLocaleLowerCase","Set","$f6cce17ab644ef19$export$ebabee42db672bb6","Object","values","trackKey","$b4e14b6b8da86996$var$getElementById","document","getElementById","$b4e14b6b8da86996$var$PARSERS","startsWith","currentArchiveTrack","currentTrack","$7836064f439eaf5e$var$parseM3U8","state","commandString","$d5b03de8161447d4$export$c32dec9fe4d709a2","$d5b03de8161447d4$export$afaa313fa0c73604","cur","$1aa7d39bd7258560$var$textReader","archiveTrack","$b4e14b6b8da86996$var$convertToReadable","fileContents","setAttribute","parserClass","parser","$b4e14b6b8da86996$var$parseArchive","errorMessage","innerText","$b4e14b6b8da86996$var$showErrorResult","dropDown","replaceChildren","option","createElement","appendChild","$b4e14b6b8da86996$var$updateSelectedPlaylist","selectedOption","selectedOptions","startTrackIndex","max","onlyPlayedTracks","filteredPlaylist","checked","textContent","$b4e14b6b8da86996$var$getFormatString","$b4e14b6b8da86996$var$uploadTracklist","e","XMLHttpRequestEventTarget","fileElement","target","file","files","reader","FileReader","readAsText","onload","$b4e14b6b8da86996$var$copyToClipboard","copyText","navigator","clipboard","writeText","$b4e14b6b8da86996$var$saveToTxtFile","blob","Blob","type","playlistName","fileName","link","download","href","URL","createObjectURL","click","$b4e14b6b8da86996$var$saveAs","window","addEventListener","fieldList","keys","fieldName","fieldListElement","extensions","accept"],"version":3,"file":"index.e51453ee.js.map"}